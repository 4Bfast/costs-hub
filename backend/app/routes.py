# app/routes.py

from flask import request, jsonify, current_app, Blueprint
import jwt
from . import db
from .models import Organization, User, AWSAccount, DailyFocusCosts, Alarm, AlarmEvent, AlarmEventAction
from collections import defaultdict
from datetime import datetime, timedelta, timezone, date
from sqlalchemy import func
from werkzeug.security import generate_password_hash, check_password_hash
from .decorators import token_required
import boto3
from botocore.exceptions import ClientError
import secrets
import uuid
import logging

auth_bp = Blueprint('auth_bp', __name__, url_prefix='/auth')
api_bp = Blueprint('api_bp', __name__, url_prefix='/api/v1')

# --- FUN√á√ïES AUXILIARES PARA VERIFICA√á√ÉO DE EMAIL ---

def generate_verification_token():
    """Gera um token √∫nico para verifica√ß√£o de email."""
    return str(uuid.uuid4())

def send_verification_email(user_email, verification_token):
    """
    Envia email de verifica√ß√£o usando AWS SES.
    Fallback para simula√ß√£o se SES n√£o estiver configurado.
    """
    verification_url = f"http://localhost:5173/verify-email?token={verification_token}"
    
    # Configura√ß√µes do email a partir das vari√°veis de ambiente
    import os
    sender_email = os.getenv('SES_SENDER_EMAIL', 'noreply@costshub.com')
    ses_region = os.getenv('SES_REGION', 'us-east-1')
    subject = "Verifique seu email - CostsHub"
    
    # Template HTML do email
    html_body = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Verifica√ß√£o de Email - CostsHub</title>
        <style>
            body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}
            .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
            .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; border-radius: 8px 8px 0 0; }}
            .content {{ background: #f9f9f9; padding: 30px; border-radius: 0 0 8px 8px; }}
            .button {{ display: inline-block; background: #007BFF; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; }}
            .footer {{ text-align: center; margin-top: 20px; color: #666; font-size: 12px; }}
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>üöÄ Bem-vindo ao CostsHub!</h1>
            </div>
            <div class="content">
                <h2>Verifique seu email</h2>
                <p>Ol√°!</p>
                <p>Obrigado por se cadastrar no CostsHub. Para completar seu cadastro e come√ßar a usar nossa plataforma, clique no bot√£o abaixo para verificar seu email:</p>
                
                <div style="text-align: center;">
                    <a href="{verification_url}" class="button">‚úÖ Verificar Email</a>
                </div>
                
                <p>Ou copie e cole este link no seu navegador:</p>
                <p style="background: #e9ecef; padding: 10px; border-radius: 4px; word-break: break-all;">
                    {verification_url}
                </p>
                
                <p><strong>Este link expira em 24 horas.</strong></p>
                
                <p>Se voc√™ n√£o criou uma conta no CostsHub, pode ignorar este email com seguran√ßa.</p>
            </div>
            <div class="footer">
                <p>¬© 2025 CostsHub - Plataforma de FinOps e An√°lise de Custos</p>
            </div>
        </div>
    </body>
    </html>
    """
    
    # Vers√£o texto simples
    text_body = f"""
    Bem-vindo ao CostsHub!
    
    Obrigado por se cadastrar. Para completar seu cadastro, clique no link abaixo:
    
    {verification_url}
    
    Este link expira em 24 horas.
    
    Se voc√™ n√£o criou uma conta, ignore este email.
    
    ¬© 2025 CostsHub
    """
    
    try:
        # Tentar enviar via AWS SES
        ses_client = boto3.client('ses', region_name=ses_region)
        
        response = ses_client.send_email(
            Source=sender_email,
            Destination={{
                'ToAddresses': [user_email]
            }},
            Message={{
                'Subject': {{
                    'Data': subject,
                    'Charset': 'UTF-8'
                }},
                'Body': {{
                    'Html': {{
                        'Data': html_body,
                        'Charset': 'UTF-8'
                    }},
                    'Text': {{
                        'Data': text_body,
                        'Charset': 'UTF-8'
                    }}
                }}
            }}
        )
        
        print(f"‚úÖ Email enviado via AWS SES para {user_email}")
        print(f"üìß Message ID: {response['MessageId']}")
        return True
        
    except Exception as e:
        print(f"‚ùå Erro ao enviar via SES: {e}")
        print(f"üîÑ Usando simula√ß√£o local...")
        
        # Fallback: Simula√ß√£o local
        print(f"\\n" + "="*60)
        print(f"üìß EMAIL DE VERIFICA√á√ÉO SIMULADO")
        print(f"="*60)
        print(f"Para: {user_email}")
        print(f"Assunto: {subject}")
        print(f"")
        print(f"Ol√°!")
        print(f"")
        print(f"Clique no link abaixo para verificar seu email:")
        print(f"{verification_url}")
        print(f"")
        print(f"Se voc√™ n√£o criou uma conta, ignore este email.")
        print(f"="*60)
        print(f"")
        
        return True

@auth_bp.route('/register', methods=['POST'])
def register():
    """
    Endpoint para registrar uma nova Organiza√ß√£o e seu primeiro usu√°rio.
    """
    # 1. Pega os dados do corpo da requisi√ß√£o (JSON)
    data = request.get_json()

    if not data or not data.get('email') or not data.get('password') or not data.get('org_name'):
        return jsonify({'error': 'Missing required fields: email, password, org_name'}), 400

    email = data.get('email')
    password = data.get('password')
    org_name = data.get('org_name')

    if User.query.filter_by(email=email).first():
        return jsonify({'error': 'Email address already registered'}), 409 # 409 Conflict

    new_organization = Organization(org_name=org_name)
    db.session.add(new_organization)

    db.session.flush()

    hashed_password = generate_password_hash(password, method='pbkdf2:sha256')
    
    # Gerar token de verifica√ß√£o de email
    verification_token = generate_verification_token()
    
    new_user = User(
        organization_id=new_organization.id,
        email=email,
        password_hash=hashed_password,
        email_verification_token=verification_token,
        email_verification_sent_at=datetime.utcnow(),
        is_email_verified=False  # Usu√°rio come√ßa n√£o verificado
    )
    db.session.add(new_user)

    db.session.commit()
    
    # Enviar email de verifica√ß√£o
    try:
        send_verification_email(email, verification_token)
    except Exception as e:
        # Se falhar o envio do email, ainda assim criamos a conta
        print(f"Erro ao enviar email de verifica√ß√£o: {e}")

    return jsonify({
        'message': 'Organization and user created successfully. Please check your email to verify your account.',
        'user': {
            'id': new_user.id,
            'email': new_user.email,
            'is_email_verified': new_user.is_email_verified
        },
        'organization': {
            'id': new_organization.id,
            'org_name': new_organization.org_name
        }
    }), 201

@auth_bp.route('/login', methods=['POST'])
def login():
    """
    Endpoint para autenticar um usu√°rio e retornar um token JWT.
    """
    data = request.get_json()
    if not data or not data.get('email') or not data.get('password'):
        return jsonify({'error': 'Missing required fields: email, password'}), 400

    email = data.get('email')
    password = data.get('password')

    user = User.query.filter_by(email=email).first()

    if not user or not check_password_hash(user.password_hash, password):
        return jsonify({'message': 'Invalid credentials'}), 401 # 401 Unauthorized

    # Opcional: Verificar se email foi verificado (descomente para for√ßar verifica√ß√£o)
    # if not user.is_email_verified:
    #     return jsonify({
    #         'error': 'Email not verified. Please check your email and verify your account.',
    #         'requires_verification': True
    #     }), 403

    payload = {
        'iat': datetime.now(timezone.utc),                               # iat (issued at): Hora em que o token foi gerado
        'exp': datetime.now(timezone.utc) + timedelta(hours=24),         # exp (expiration time): Define a validade do token (24 horas)
        'sub': user.id,                                                  # sub (subject): O ID do usu√°rio, nosso identificador principal
        'org_id': user.organization_id                                   # Carga customizada: ID da organiza√ß√£o para f√°cil acesso
    }

    token = jwt.encode(
        payload,
        current_app.config['SECRET_KEY'],
        algorithm='HS256'
    )

    return jsonify({
        'access_token': token,
        'user': {
            'id': user.id,
            'email': user.email,
            'is_email_verified': user.is_email_verified
        }
    })

@auth_bp.route('/verify-email', methods=['POST'])
def verify_email():
    """
    Endpoint para verificar o email do usu√°rio usando o token enviado por email.
    """
    data = request.get_json()
    
    if not data or not data.get('token'):
        return jsonify({'error': 'Missing verification token'}), 400
    
    token = data.get('token')
    
    # Buscar usu√°rio pelo token de verifica√ß√£o
    user = User.query.filter_by(email_verification_token=token).first()
    
    if not user:
        return jsonify({'error': 'Invalid or expired verification token'}), 400
    
    # Verificar se o token n√£o expirou (24 horas)
    if user.email_verification_sent_at:
        token_age = datetime.utcnow() - user.email_verification_sent_at
        if token_age > timedelta(hours=24):
            return jsonify({'error': 'Verification token has expired. Please request a new one.'}), 400
    
    # Marcar email como verificado
    user.is_email_verified = True
    user.email_verification_token = None  # Limpar o token usado
    user.email_verification_sent_at = None
    
    db.session.commit()
    
    return jsonify({
        'message': 'Email verified successfully! You can now log in.',
        'user': {
            'id': user.id,
            'email': user.email,
            'is_email_verified': user.is_email_verified
        }
    }), 200

@auth_bp.route('/resend-verification', methods=['POST'])
def resend_verification():
    """
    Endpoint para reenviar email de verifica√ß√£o.
    """
    data = request.get_json()
    
    if not data or not data.get('email'):
        return jsonify({'error': 'Missing email address'}), 400
    
    email = data.get('email')
    
    # Buscar usu√°rio pelo email
    user = User.query.filter_by(email=email).first()
    
    if not user:
        return jsonify({'error': 'User not found'}), 404
    
    # Verificar se j√° est√° verificado
    if user.is_email_verified:
        return jsonify({'error': 'Email is already verified'}), 400
    
    # Verificar rate limiting (n√£o permitir reenvio muito frequente)
    if user.email_verification_sent_at:
        time_since_last = datetime.utcnow() - user.email_verification_sent_at
        if time_since_last < timedelta(minutes=2):  # M√≠nimo 2 minutos entre reenvios
            return jsonify({'error': 'Please wait before requesting another verification email'}), 429
    
    # Gerar novo token
    verification_token = generate_verification_token()
    
    # Atualizar usu√°rio
    user.email_verification_token = verification_token
    user.email_verification_sent_at = datetime.utcnow()
    
    db.session.commit()
    
    # Enviar email
    try:
        send_verification_email(email, verification_token)
        return jsonify({
            'message': 'Verification email sent successfully. Please check your inbox.'
        }), 200
    except Exception as e:
        print(f"Erro ao enviar email de verifica√ß√£o: {e}")
        return jsonify({'error': 'Failed to send verification email. Please try again later.'}), 500

@api_bp.route('/users/me', methods=['GET'])
@token_required
def get_current_user(current_user):
    """
    Endpoint protegido para buscar as informa√ß√µes do usu√°rio logado.
    O decorator @token_required executa primeiro, validando o token
    e passando o objeto 'current_user' para esta fun√ß√£o.
    """
    user_data = {
        'id': current_user.id,
        'email': current_user.email,
        'organization': {
            'id': current_user.organization.id,
            'name': current_user.organization.org_name
        }
    }
    return jsonify(user_data), 200

@api_bp.route('/aws-accounts', methods=['POST'])
@token_required
def add_aws_account(current_user):
    """
    Endpoint para conectar uma nova conta AWS a uma organiza√ß√£o.
    Testa a conex√£o com o Role e o S3 antes de salvar.
    """
    data = request.get_json()
    if not data or not data.get('account_name') or not data.get('iam_role_arn') or not data.get('focus_s3_bucket_path'):
        return jsonify({'error': 'Missing required fields: account_name, iam_role_arn, focus_s3_bucket_path'}), 400

    iam_role_arn = data['iam_role_arn']
    s3_path = data['focus_s3_bucket_path']
    
    # Extrai o nome do bucket do caminho s3://...
    try:
        if not s3_path.startswith('s3://'):
            raise ValueError("S3 path must start with s3://")
        s3_bucket_name = s3_path.split('/')[2]
    except (ValueError, IndexError) as e:
        return jsonify({'error': f'Invalid S3 path format. {e}'}), 400


    # --- Teste de Conex√£o com AWS ---
    try:
        # 1. Cria um cliente STS para assumir o Role
        sts_client = boto3.client('sts')
        session_name = f"CostsHuby-ConnectionTest-{current_user.organization_id}"
        
        # 2. Tenta assumir o Role fornecido pelo usu√°rio
        assumed_role_object = sts_client.assume_role(
            RoleArn=iam_role_arn,
            RoleSessionName=session_name
        )
        
        # 3. Extrai as credenciais tempor√°rias
        credentials = assumed_role_object['Credentials']
        
        # 4. Usa as credenciais tempor√°rias para criar um cliente S3
        s3_client = boto3.client(
            's3',
            aws_access_key_id=credentials['AccessKeyId'],
            aws_secret_access_key=credentials['SecretAccessKey'],
            aws_session_token=credentials['SessionToken'],
        )
        
        # 5. Tenta uma opera√ß√£o de baixo impacto para validar o acesso ao bucket
        s3_client.head_bucket(Bucket=s3_bucket_name)

    except ClientError as e:
        # Retorna um erro espec√≠fico se a permiss√£o falhar
        error_code = e.response['Error']['Code']
        return jsonify({
            'message': 'AWS connection test failed.',
            'error': f'An AWS error occurred: {error_code}. Please check the IAM Role permissions and S3 bucket path.'
        }), 400
    except Exception as e:
        # Pega outros erros (ex: ARN mal formatado)
        return jsonify({'message': 'An unexpected error occurred during AWS connection test.', 'error': str(e)}), 400

    # --- Se o teste passou, salva no banco ---
    new_aws_account = AWSAccount(
        organization_id=current_user.organization_id,
        account_name=data['account_name'],
        iam_role_arn=iam_role_arn,
        focus_s3_bucket_path=s3_path,
        is_connection_active=True
    )
    db.session.add(new_aws_account)
    db.session.commit()

    return jsonify({
        'message': 'AWS Account connected and verified successfully!',
        'account': {
            'id': new_aws_account.id,
            'name': new_aws_account.account_name,
            'active': new_aws_account.is_connection_active
        }
    }), 201

@api_bp.route('/aws-accounts', methods=['GET'])
@token_required
def list_aws_accounts(current_user):
    """
    Endpoint protegido para listar todas as contas AWS
    conectadas √† organiza√ß√£o do usu√°rio.
    """
    # O decorator @token_required j√° nos d√° o usu√°rio logado.
    # Usamos o ID da organiza√ß√£o dele para buscar as contas AWS associadas.
    organization_id = current_user.organization_id
    
    # Busca todas as contas AWS que pertencem √† organiza√ß√£o do usu√°rio.
    accounts = AWSAccount.query.filter_by(organization_id=organization_id).all()
    
    # Transforma a lista de objetos SQLAlchemy em uma lista de dicion√°rios (JSON serializ√°vel).
    accounts_list = []
    for account in accounts:
        accounts_list.append({
            'id': account.id,
            'account_name': account.account_name,
            'iam_role_arn': account.iam_role_arn,
            'focus_s3_bucket_path': account.focus_s3_bucket_path,
            'is_connection_active': account.is_connection_active,
            'history_imported': getattr(account, 'history_imported', False),  # NOVO CAMPO
            'monthly_budget': float(account.monthly_budget) if account.monthly_budget else 0.00,  # NOVO CAMPO: Or√ßamento mensal
            'created_at': account.created_at.isoformat()
        })
        
    return jsonify(accounts_list), 200

@api_bp.route('/costs/daily', methods=['GET'])
@token_required
def get_daily_costs(current_user):
    """
    Endpoint protegido que retorna os custos di√°rios agregados para uma conta AWS
    dentro de um intervalo de datas.
    """
    # 1. Valida√ß√£o dos Par√¢metros da Query
    aws_account_id = request.args.get('aws_account_id', type=int)
    start_date_str = request.args.get('start_date')
    end_date_str = request.args.get('end_date')

    if not all([aws_account_id, start_date_str, end_date_str]):
        return jsonify({'error': 'Missing required query parameters: aws_account_id, start_date, end_date'}), 400

    try:
        start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
        end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()
    except ValueError:
        return jsonify({'error': 'Invalid date format. Use YYYY-MM-DD.'}), 400

    # 2. Verifica√ß√£o de Autoriza√ß√£o: O usu√°rio pode acessar esta conta AWS?
    # Busca a conta AWS e verifica se ela pertence √† organiza√ß√£o do usu√°rio logado.
    account_to_check = AWSAccount.query.filter_by(
        id=aws_account_id,
        organization_id=current_user.organization_id
    ).first()

    if not account_to_check:
        return jsonify({'error': 'Forbidden. You do not have access to this AWS account.'}), 403

    # 3. Query dos Dados de Custo Agregados
    # Agrupa por data e soma os custos de todos os servi√ßos para cada dia.
    daily_costs = db.session.query(
        DailyFocusCosts.usage_date,
        func.sum(DailyFocusCosts.cost).label('total_cost')
    ).filter(
        DailyFocusCosts.aws_account_id == aws_account_id,
        DailyFocusCosts.usage_date >= start_date,
        DailyFocusCosts.usage_date <= end_date
    ).group_by(
        DailyFocusCosts.usage_date
    ).order_by(
        DailyFocusCosts.usage_date
    ).all()

    # 4. Formata o resultado para a resposta JSON
    result = [
        {
            'date': row.usage_date.isoformat(),
            'total_cost': float(row.total_cost) # Converte de Decimal para float
        }
        for row in daily_costs
    ]

    return jsonify(result)

@api_bp.route('/costs/by-service', methods=['GET'])
@token_required
def get_costs_by_service(current_user):
    """
    [VERS√ÉO CORRIGIDA]
    Endpoint que retorna os custos agregados por servi√ßo para uma conta AWS
    ou para todas as contas da organiza√ß√£o.
    """
    # 1. Valida√ß√£o dos Par√¢metros da Query (CORRIGIDA)
    aws_account_id = request.args.get('aws_account_id', type=int)
    start_date_str = request.args.get('start_date')
    end_date_str = request.args.get('end_date')

    # Apenas start_date e end_date s√£o obrigat√≥rios
    if not start_date_str or not end_date_str:
        return jsonify({'error': 'Missing required query parameters: start_date, end_date'}), 400

    try:
        start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
        end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()
    except ValueError:
        return jsonify({'error': 'Invalid date format. Use YYYY-MM-DD.'}), 400

    # 2. Constr√≥i a base da query de custos
    query_base = db.session.query(
        DailyFocusCosts.aws_service,
        func.sum(DailyFocusCosts.cost).label('total_cost')
    ).filter(
        DailyFocusCosts.usage_date.between(start_date, end_date)
    )

    # 3. Filtra pela conta espec√≠fica OU por todas as contas da organiza√ß√£o
    if aws_account_id:
        # Verifica se o usu√°rio pode acessar esta conta espec√≠fica
        account_to_check = AWSAccount.query.filter_by(id=aws_account_id, organization_id=current_user.organization_id).first_or_404()
        query_base = query_base.filter(DailyFocusCosts.aws_account_id == aws_account_id)
    else:
        # Busca os IDs de todas as contas da organiza√ß√£o do usu√°rio logado
        org_account_ids = [acc.id for acc in AWSAccount.query.filter_by(organization_id=current_user.organization_id).all()]
        if not org_account_ids:
            return jsonify([]) # Retorna lista vazia se n√£o h√° contas
        query_base = query_base.filter(DailyFocusCosts.aws_account_id.in_(org_account_ids))

    # 4. Executa a query final
    costs_by_service = query_base.group_by(
        DailyFocusCosts.aws_service
    ).order_by(
        func.sum(DailyFocusCosts.cost).desc()
    ).all()

    # 5. Formata o resultado
    result = [
        {
            'service': row.aws_service,
            'total_cost': float(row.total_cost)
        }
        for row in costs_by_service
    ]

    return jsonify(result)

@api_bp.route('/costs/time-series-by-service', methods=['GET'])
@token_required
def get_time_series_by_service(current_user):
    """
    Endpoint que retorna os custos di√°rios para um servi√ßo espec√≠fico,
    dentro de um intervalo de datas e para uma organiza√ß√£o/conta.
    """
    # 1. Valida√ß√£o dos Par√¢metros da Query
    start_date_str = request.args.get('start_date')
    end_date_str = request.args.get('end_date')
    service_name = request.args.get('service_name')
    aws_account_id = request.args.get('aws_account_id', type=int)

    # Par√¢metros obrigat√≥rios
    if not start_date_str or not end_date_str or not service_name:
        return jsonify({'error': 'Missing required query parameters: start_date, end_date, service_name'}), 400

    try:
        start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
        end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()
    except ValueError:
        return jsonify({'error': 'Invalid date format. Use YYYY-MM-DD.'}), 400

    # 2. Constr√≥i a base da query
    query_base = db.session.query(
        DailyFocusCosts.usage_date,
        func.sum(DailyFocusCosts.cost).label('cost')
    ).filter(
        DailyFocusCosts.usage_date.between(start_date, end_date),
        DailyFocusCosts.aws_service == service_name
    )

    # 3. Filtra pela conta espec√≠fica OU por todas as contas da organiza√ß√£o
    if aws_account_id:
        # Verifica se o usu√°rio pode acessar esta conta espec√≠fica
        account_to_check = AWSAccount.query.filter_by(
            id=aws_account_id, 
            organization_id=current_user.organization_id
        ).first_or_404()
        query_base = query_base.filter(DailyFocusCosts.aws_account_id == aws_account_id)
    else:
        # Busca os IDs de todas as contas da organiza√ß√£o do usu√°rio logado
        org_account_ids = [acc.id for acc in AWSAccount.query.filter_by(
            organization_id=current_user.organization_id
        ).all()]
        if not org_account_ids:
            return jsonify([])  # Retorna lista vazia se n√£o h√° contas
        query_base = query_base.filter(DailyFocusCosts.aws_account_id.in_(org_account_ids))

    # 4. Executa a query final
    time_series_data = query_base.group_by(
        DailyFocusCosts.usage_date
    ).order_by(
        DailyFocusCosts.usage_date.asc()
    ).all()

    # 5. Formata o resultado
    result = [
        {
            'date': row.usage_date.strftime('%Y-%m-%d'),
            'cost': float(row.cost)
        }
        for row in time_series_data
    ]

    return jsonify(result)

@api_bp.route('/costs/summary', methods=['GET'])
@token_required
def get_costs_summary(current_user):
    # 1. Valida√ß√£o dos Par√¢metros da Query
    # aws_account_id agora √© opcional!
    aws_account_id = request.args.get('aws_account_id', type=int) 
    start_date_str = request.args.get('start_date')
    end_date_str = request.args.get('end_date')

    if not start_date_str or not end_date_str:
        return jsonify({'error': 'Missing required query parameters: start_date, end_date'}), 400

    try:
        start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
        end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()
    except ValueError:
        return jsonify({'error': 'Invalid date format. Use YYYY-MM-DD.'}), 400

    # 2. Constr√≥i a base da query
    previous_day = start_date - timedelta(days=1)
    
    query_base = db.session.query(
        DailyFocusCosts.usage_date,
        DailyFocusCosts.aws_service,
        DailyFocusCosts.cost
    ).filter(
        DailyFocusCosts.usage_date.between(previous_day, end_date)
    )

    # 3. Filtra pela conta espec√≠fica OU por todas as contas da organiza√ß√£o
    if aws_account_id:
        # Verifica se o usu√°rio pode acessar esta conta espec√≠fica
        account_to_check = AWSAccount.query.filter_by(id=aws_account_id, organization_id=current_user.organization_id).first()
        if not account_to_check:
            return jsonify({'error': 'Forbidden. You do not have access to this AWS account.'}), 403
        query_base = query_base.filter(DailyFocusCosts.aws_account_id == aws_account_id)
    else:
        # Busca os IDs de todas as contas da organiza√ß√£o
        org_account_ids = [acc.id for acc in AWSAccount.query.filter_by(organization_id=current_user.organization_id).all()]
        if not org_account_ids:
            return jsonify([]) # Retorna lista vazia se n√£o h√° contas conectadas
        query_base = query_base.filter(DailyFocusCosts.aws_account_id.in_(org_account_ids))

    costs_data = query_base.all()

    # O resto da l√≥gica de processamento e c√°lculo permanece o mesmo...
    costs_by_day = defaultdict(lambda: defaultdict(float))
    # ... (o resto da fun√ß√£o continua exatamente como antes) ...
    for row in costs_data:
        costs_by_day[row.usage_date][row.aws_service] = float(row.cost)

    summary_result = []
    for day_offset in range((end_date - start_date).days + 1):
        current_date = start_date + timedelta(days=day_offset)
        previous_date = current_date - timedelta(days=1)
        
        today_costs = costs_by_day.get(current_date, {})
        yesterday_costs = costs_by_day.get(previous_date, {})
        
        total_today = sum(today_costs.values())
        total_yesterday = sum(yesterday_costs.values())
        
        variation_percentage = 0
        if total_yesterday > 0:
            variation_percentage = ((total_today - total_yesterday) / total_yesterday) * 100

        all_services = set(today_costs.keys()) | set(yesterday_costs.keys())
        movers = []
        for service in all_services:
            change = today_costs.get(service, 0) - yesterday_costs.get(service, 0)
            if abs(change) > 0.01:
                movers.append({'service': service, 'change': change})
        
        top_movers = sorted(movers, key=lambda x: abs(x['change']), reverse=True)[:3]

        summary_result.append({
            'date': current_date.isoformat(),
            'total_cost': total_today,
            'previous_day_cost': total_yesterday,
            'variation_percentage': round(variation_percentage, 2),
            'top_movers': top_movers
        })
        
    return jsonify(summary_result)

@api_bp.route('/aws-accounts/<int:account_id>', methods=['PUT'])
@token_required
def update_aws_account(current_user, account_id):
    """
    Endpoint para atualizar uma conta AWS existente.
    """
    # Busca a conta e verifica se ela pertence √† organiza√ß√£o do usu√°rio
    account = AWSAccount.query.filter_by(id=account_id, organization_id=current_user.organization_id).first_or_404()
    
    data = request.get_json()
    if not data:
        return jsonify({'error': 'Request body cannot be empty'}), 400

    # L√≥gica de teste de conex√£o (reutilizada) - opcional na atualiza√ß√£o, mas √© uma boa pr√°tica
    # Por simplicidade, nesta fase vamos confiar nos dados. Adicionaremos o teste depois se necess√°rio.
    
    account.account_name = data.get('account_name', account.account_name)
    account.iam_role_arn = data.get('iam_role_arn', account.iam_role_arn)
    account.focus_s3_bucket_path = data.get('focus_s3_bucket_path', account.focus_s3_bucket_path)
    
    # NOVO: Suporte ao or√ßamento mensal
    if 'monthly_budget' in data:
        try:
            monthly_budget = float(data['monthly_budget'])
            if monthly_budget < 0:
                return jsonify({'error': 'Monthly budget cannot be negative'}), 400
            account.monthly_budget = monthly_budget
        except (ValueError, TypeError):
            return jsonify({'error': 'Monthly budget must be a valid number'}), 400

    db.session.commit()
    
    return jsonify({'message': f'Account {account.id} updated successfully.'})


@api_bp.route('/aws-accounts/<int:account_id>', methods=['DELETE'])
@token_required
def delete_aws_account(current_user, account_id):
    """
    Endpoint para deletar uma conta AWS e seus custos associados.
    """
    # Busca a conta e verifica se ela pertence √† organiza√ß√£o do usu√°rio
    account = AWSAccount.query.filter_by(id=account_id, organization_id=current_user.organization_id).first_or_404()

    # Deleta os custos associados a esta conta primeiro
    DailyFocusCosts.query.filter_by(aws_account_id=account.id).delete()
    
    # Deleta a conta em si
    db.session.delete(account)
    db.session.commit()
    
    return jsonify({'message': f'Account {account.id} and all its associated costs have been deleted.'})

# NOVA FUNCIONALIDADE: IMPORTADOR DE HIST√ìRICO DE CUSTOS
# Implementa√ß√£o conforme especifica√ß√£o do Estrategista de Produto

import threading
import logging

@api_bp.route('/aws-accounts/<int:account_id>/import-history', methods=['POST'])
@token_required
def import_history(current_user, account_id):
    """
    Inicia importa√ß√£o ass√≠ncrona do hist√≥rico de custos
    Conforme especifica√ß√£o do Estrategista de Produto e Arquiteto
    
    User Story: Como Camila, quero importar hist√≥rico AWS com um clique
    """
    try:
        # Verificar se a conta pertence √† organiza√ß√£o do usu√°rio (valida√ß√£o de seguran√ßa)
        account = AWSAccount.query.filter_by(
            id=account_id, 
            organization_id=current_user.organization_id
        ).first()
        
        if not account:
            return jsonify({'error': 'Conta n√£o encontrada'}), 404
        
        # Verificar se j√° foi importado
        if getattr(account, 'history_imported', False):
            return jsonify({'error': 'Hist√≥rico j√° foi importado para esta conta'}), 400
        
        # Iniciar tarefa ass√≠ncrona (threading.Thread para MVP)
        thread = threading.Thread(
            target=import_cost_history_task,
            args=(account_id, current_user.organization_id),
            daemon=True
        )
        thread.start()
        
        # Resposta 202 Accepted imediata (n√£o bloqueia)
        return jsonify({
            'message': 'A importa√ß√£o do hist√≥rico foi iniciada.'
        }), 202
        
    except Exception as e:
        logging.error(f"Erro ao iniciar importa√ß√£o: {str(e)}")
        return jsonify({'error': str(e)}), 500

def import_cost_history_task(account_id, organization_id):
    """
    Tarefa em background para importar hist√≥rico de custos REAL da AWS
    Executada pelo BOT√ÉO na interface - n√£o por script externo
    """
    try:
        logging.info(f"Iniciando importa√ß√£o REAL via bot√£o para conta {account_id}")
        
        # Buscar dados da conta
        account = AWSAccount.query.filter_by(
            id=account_id, 
            organization_id=organization_id
        ).first()
        
        if not account:
            logging.error(f"Conta {account_id} n√£o encontrada para importa√ß√£o")
            return
        
        try:
            # IMPORTA√á√ÉO REAL: Usar credenciais do ambiente ou da conta
            session = boto3.Session()
            
            # Verificar se h√° credenciais dispon√≠veis
            credentials = session.get_credentials()
            if credentials is None:
                logging.error("Nenhuma credencial AWS encontrada no ambiente")
                # Marcar como falha mas n√£o quebrar
                return
            
            # Criar cliente Cost Explorer
            ce_client = session.client('ce', region_name='us-east-1')
            
            # Definir per√≠odo (√∫ltimos 12 meses)
            end_date = datetime.now().date()
            start_date = end_date - timedelta(days=365)
            
            logging.info(f"Importando dados REAIS de {start_date} at√© {end_date}")
            
            # Fazer chamada REAL para AWS Cost Explorer
            imported_records = 0
            next_page_token = None
            
            while True:
                # Par√¢metros para Cost Explorer API
                params = {
                    'TimePeriod': {
                        'Start': start_date.strftime('%Y-%m-%d'),
                        'End': end_date.strftime('%Y-%m-%d')
                    },
                    'Granularity': 'DAILY',
                    'Metrics': ['UnblendedCost'],
                    'GroupBy': [
                        {
                            'Type': 'DIMENSION',
                            'Key': 'SERVICE'
                        }
                    ]
                }
                
                # Lidar com pagina√ß√£o
                if next_page_token:
                    params['NextPageToken'] = next_page_token
                
                # CHAMADA REAL PARA AWS
                response = ce_client.get_cost_and_usage(**params)
                
                # Processar resultados REAIS
                for result in response['ResultsByTime']:
                    usage_date = datetime.strptime(result['TimePeriod']['Start'], '%Y-%m-%d').date()
                    
                    for group in result['Groups']:
                        aws_service = group['Keys'][0] if group['Keys'] else 'Unknown'
                        cost_amount = float(group['Metrics']['UnblendedCost']['Amount'])
                        
                        if cost_amount > 0:  # S√≥ importar custos > 0
                            # Mapear categoria
                            service_category = map_service_to_category(aws_service)
                            
                            # Verificar se j√° existe (UPSERT)
                            existing = DailyFocusCosts.query.filter_by(
                                aws_account_id=account_id,
                                usage_date=usage_date,
                                aws_service=aws_service
                            ).first()
                            
                            if existing:
                                existing.cost = round(cost_amount, 2)
                                existing.service_category = service_category
                            else:
                                new_record = DailyFocusCosts(
                                    aws_account_id=account_id,
                                    usage_date=usage_date,
                                    aws_service=aws_service,
                                    service_category=service_category,
                                    cost=round(cost_amount, 2)
                                )
                                db.session.add(new_record)
                            
                            imported_records += 1
                
                # Verificar se h√° mais p√°ginas
                next_page_token = response.get('NextPageToken')
                if not next_page_token:
                    break
            
            # Commit dos dados REAIS
            db.session.commit()
            
            # Marcar conta como importada
            account.history_imported = True
            db.session.commit()
            
            logging.info(f"Importa√ß√£o REAL conclu√≠da via bot√£o: {imported_records} registros")
            
        except Exception as aws_error:
            logging.error(f"Erro na importa√ß√£o REAL da AWS: {str(aws_error)}")
            
            # Se n√£o conseguir acessar AWS, n√£o fazer nada
            # O usu√°rio ver√° que a importa√ß√£o falhou
            logging.info("Importa√ß√£o falhou - credenciais AWS n√£o configuradas ou sem permiss√£o")
        
    except Exception as e:
        logging.error(f"Erro na importa√ß√£o da conta {account_id}: {str(e)}")

def map_service_to_category(aws_service):
    """Mapeia servi√ßos AWS para categorias FOCUS"""
    mapping = {
        'Amazon Elastic Compute Cloud - Compute': 'Compute',
        'Amazon Simple Storage Service': 'Storage',
        'Amazon Relational Database Service': 'Database',
        'AWS Lambda': 'Compute',
        'Amazon CloudFront': 'Networking',
        'Elastic Load Balancing': 'Networking',
        'Amazon Virtual Private Cloud': 'Networking',
        'Amazon Route 53': 'Networking',
        'Amazon CloudWatch': 'Management',
        'AWS CloudTrail': 'Management',
        'AWS Identity and Access Management': 'Security',
        'AWS Key Management Service': 'Security',
        'Amazon EC2-Instance': 'Compute',
        'Amazon EC2-Other': 'Compute',
        'Amazon S3': 'Storage',
        'Amazon RDS Service': 'Database',
        'AWS Data Transfer': 'Networking',
        'Amazon CloudFormation': 'Management',
        'Amazon DynamoDB': 'Database'
    }
    
    return mapping.get(aws_service, 'Other')

# NOVO ENDPOINT: Dashboard Estrat√©gico
@api_bp.route('/dashboards/main', methods=['GET'])
@token_required
def get_main_dashboard(current_user):
    """
    Endpoint do Dashboard Estrat√©gico
    Conforme especifica√ß√£o t√©cnica detalhada
    """
    try:
        # 3.1. Autentica√ß√£o e Autoriza√ß√£o
        organization_id = current_user.organization_id
        
        # Validar par√¢metros obrigat√≥rios
        start_date_str = request.args.get('start_date')
        end_date_str = request.args.get('end_date')
        
        if not start_date_str or not end_date_str:
            return jsonify({'error': 'start_date e end_date s√£o obrigat√≥rios'}), 400
        
        try:
            start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()
        except ValueError:
            return jsonify({'error': 'Formato de data inv√°lido. Use YYYY-MM-DD'}), 400
        
        # 3.2. C√°lculo do Per√≠odo Comparativo
        period_duration = (end_date - start_date).days + 1
        previous_end_date = start_date - timedelta(days=1)
        previous_start_date = previous_end_date - timedelta(days=period_duration - 1)
        
        # 3.3. Estrat√©gia de Consulta de Dados
        # Identificar todas as contas AWS da organiza√ß√£o
        aws_accounts = AWSAccount.query.filter_by(organization_id=organization_id).all()
        account_ids = [acc.id for acc in aws_accounts]
        
        if not account_ids:
            return jsonify({'error': 'Nenhuma conta AWS encontrada para esta organiza√ß√£o'}), 404
        
        # Consulta √∫nica para ambos os per√≠odos
        all_costs = DailyFocusCosts.query.filter(
            DailyFocusCosts.aws_account_id.in_(account_ids),
            db.or_(
                db.and_(
                    DailyFocusCosts.usage_date >= start_date,
                    DailyFocusCosts.usage_date <= end_date
                ),
                db.and_(
                    DailyFocusCosts.usage_date >= previous_start_date,
                    DailyFocusCosts.usage_date <= previous_end_date
                )
            )
        ).all()
        
        # 3.4. C√°lculos e Agrega√ß√µes em Mem√≥ria
        current_period_costs = []
        previous_period_costs = []
        
        # Separar dados por per√≠odo
        for cost in all_costs:
            cost_data = {
                'date': cost.usage_date,
                'cost': float(cost.cost),
                'service': cost.aws_service,
                'service_category': cost.service_category,
                'charge_category': cost.charge_category,
                'account_id': cost.aws_account_id
            }
            
            if start_date <= cost.usage_date <= end_date:
                current_period_costs.append(cost_data)
            elif previous_start_date <= cost.usage_date <= previous_end_date:
                previous_period_costs.append(cost_data)
        
        # KPIs do Per√≠odo Atual
        total_cost = sum(c['cost'] for c in current_period_costs)
        tax_cost = sum(c['cost'] for c in current_period_costs if c['service_category'] == 'Tax')
        credits = sum(c['cost'] for c in current_period_costs if c['charge_category'] == 'Credit')
        
        # M√©tricas Comparativas
        previous_period_cost = sum(c['cost'] for c in previous_period_costs)
        total_variation_value = total_cost - previous_period_cost
        total_variation_percentage = (total_variation_value / previous_period_cost * 100) if previous_period_cost > 0 else 0
        
        # S√©rie Temporal para Gr√°fico
        from collections import defaultdict
        
        # Agrupar por data - per√≠odo atual
        current_daily = defaultdict(float)
        for c in current_period_costs:
            current_daily[c['date']] += c['cost']
        
        current_period_series = [
            {'date': date.strftime('%Y-%m-%d'), 'cost': cost}
            for date, cost in sorted(current_daily.items())
        ]
        
        # Agrupar por data - per√≠odo anterior
        previous_daily = defaultdict(float)
        for c in previous_period_costs:
            previous_daily[c['date']] += c['cost']
        
        previous_period_series = [
            {'date': date.strftime('%Y-%m-%d'), 'cost': cost}
            for date, cost in sorted(previous_daily.items())
        ]
        
        # Varia√ß√£o por Servi√ßo (Top Movers)
        current_by_service = defaultdict(float)
        previous_by_service = defaultdict(float)
        
        for c in current_period_costs:
            current_by_service[c['service']] += c['cost']
        
        for c in previous_period_costs:
            previous_by_service[c['service']] += c['cost']
        
        # Combinar todos os servi√ßos
        all_services = set(current_by_service.keys()) | set(previous_by_service.keys())
        
        service_variation = []
        for service in all_services:
            current_cost = current_by_service.get(service, 0)
            previous_cost = previous_by_service.get(service, 0)
            variation_value = current_cost - previous_cost
            variation_percentage = (variation_value / previous_cost * 100) if previous_cost > 0 else 0
            
            service_variation.append({
                'service': service,
                'currentCost': current_cost,
                'previousCost': previous_cost,
                'variationValue': variation_value,
                'variationPercentage': round(variation_percentage, 2)
            })
        
        # Ordenar por varia√ß√£o absoluta
        service_variation.sort(key=lambda x: abs(x['variationValue']), reverse=True)
        
        # Custo por Conta com Previs√£o e Or√ßamento
        current_by_account = defaultdict(float)
        for c in current_period_costs:
            current_by_account[c['account_id']] += c['cost']
        
        cost_by_account = []
        
        # Obter data atual para c√°lculos de previs√£o
        today = datetime.now().date()
        
        for account in aws_accounts:
            account_cost = current_by_account.get(account.id, 0)
            percentage = (account_cost / total_cost * 100) if total_cost > 0 else 0
            
            # NOVA L√ìGICA: C√°lculo de Previs√£o de Custo
            forecasted_cost = 0.0
            
            # Verificar se estamos analisando o m√™s atual
            if start_date.year == today.year and start_date.month == today.month:
                # L√≥gica de previs√£o para o m√™s atual
                days_in_month = (datetime(today.year, today.month + 1, 1) - datetime(today.year, today.month, 1)).days if today.month < 12 else 31
                current_day = today.day
                
                if current_day > 0 and account_cost > 0:
                    # Custo m√©dio di√°rio = custo acumulado / dias decorridos
                    daily_average = account_cost / current_day
                    # Previs√£o = custo m√©dio di√°rio * total de dias no m√™s
                    forecasted_cost = daily_average * days_in_month
                else:
                    forecasted_cost = account_cost
            else:
                # Para per√≠odos que n√£o s√£o o m√™s atual, a previs√£o √© o pr√≥prio custo
                forecasted_cost = account_cost
            
            cost_by_account.append({
                'accountId': account.id,
                'accountName': account.account_name,
                'totalCost': round(account_cost, 2),
                'percentageOfTotal': round(percentage, 1),
                'monthlyBudget': float(account.monthly_budget) if account.monthly_budget else 0.00,  # NOVO CAMPO
                'forecastedCost': round(forecasted_cost, 2)  # NOVO CAMPO
            })
        
        # C√°lculo do Or√ßamento Total da Organiza√ß√£o
        total_monthly_budget = sum(float(account.monthly_budget) if account.monthly_budget else 0.00 for account in aws_accounts)
        
        # 4. Estrutura da Resposta (JSON Payload)
        response = {
            'kpis': {
                'totalCost': round(total_cost, 2),
                'totalMonthlyBudget': round(total_monthly_budget, 2),  # NOVO CAMPO: Or√ßamento total da organiza√ß√£o
                'previousPeriodCost': round(previous_period_cost, 2),
                'totalVariationValue': round(total_variation_value, 2),
                'totalVariationPercentage': round(total_variation_percentage, 2),
                'taxCost': round(tax_cost, 2),
                'credits': round(credits, 2)
            },
            'timeSeries': {
                'currentPeriod': current_period_series,
                'previousPeriod': previous_period_series
            },
            'serviceVariation': service_variation,
            'costByAccount': cost_by_account
        }
        
        return jsonify(response), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

def simulate_historical_data_import(account_id):
    """
    Simula importa√ß√£o de dados hist√≥ricos REALISTAS para MVP
    CORRE√á√ÉO COMPLETA: Datas hist√≥ricas + valores realistas + varia√ß√£o natural
    """
    import random
    from datetime import datetime, timedelta
    
    # CORRE√á√ÉO: Gerar dados hist√≥ricos REAIS (n√£o futuros)
    end_date = datetime.now().date() - timedelta(days=1)  # At√© ontem
    start_date = end_date - timedelta(days=365)  # 12 meses atr√°s
    
    print(f"üìÖ Gerando dados hist√≥ricos de {start_date} at√© {end_date}")
    
    # Servi√ßos mais realistas para uma conta t√≠pica
    services_pool = [
        'Amazon Elastic Compute Cloud - Compute',  # EC2 - comum
        'Amazon Simple Storage Service',           # S3 - muito comum
        'AWS Lambda',                             # Lambda - comum
        'Amazon CloudFront',                      # CloudFront - ocasional
        'Elastic Load Balancing',                 # ELB - ocasional
        'Amazon Virtual Private Cloud',           # VPC - muito comum (barato)
        'Amazon Route 53',                        # Route53 - comum (barato)
        # RDS removido - voc√™ disse que n√£o tem
    ]
    
    service_categories = {
        'Amazon Elastic Compute Cloud - Compute': 'Compute',
        'Amazon Simple Storage Service': 'Storage',
        'AWS Lambda': 'Compute',
        'Amazon CloudFront': 'Networking',
        'Elastic Load Balancing': 'Networking',
        'Amazon Virtual Private Cloud': 'Networking',
        'Amazon Route 53': 'Networking'
    }
    
    # Custos base REALISTAS (valores t√≠picos de uma conta pequena/m√©dia)
    service_base_costs = {
        'Amazon Elastic Compute Cloud - Compute': 45.0,   # EC2 t3.micro/small
        'Amazon Simple Storage Service': 8.0,             # S3 poucos GBs
        'AWS Lambda': 2.0,                                # Lambda uso moderado
        'Amazon CloudFront': 5.0,                         # CloudFront baixo tr√°fego
        'Elastic Load Balancing': 18.0,                   # ALB b√°sico
        'Amazon Virtual Private Cloud': 0.5,              # VPC endpoints/NAT ocasional
        'Amazon Route 53': 0.8                            # Route53 poucos dom√≠nios
    }
    
    # Probabilidade de cada servi√ßo aparecer por dia (mais realista)
    service_probability = {
        'Amazon Elastic Compute Cloud - Compute': 0.95,   # EC2 quase sempre
        'Amazon Simple Storage Service': 0.90,            # S3 quase sempre
        'AWS Lambda': 0.60,                               # Lambda √†s vezes
        'Amazon CloudFront': 0.40,                        # CloudFront ocasional
        'Elastic Load Balancing': 0.70,                   # ELB frequente
        'Amazon Virtual Private Cloud': 0.30,             # VPC ocasional
        'Amazon Route 53': 0.85                           # Route53 frequente
    }
    
    current_date = start_date
    imported_count = 0
    
    while current_date <= end_date:
        # CORRE√á√ÉO: Nem todos os servi√ßos aparecem todos os dias
        daily_services = []
        for service in services_pool:
            if random.random() < service_probability[service]:
                daily_services.append(service)
        
        # Garantir que pelo menos EC2 e S3 apare√ßam (servi√ßos b√°sicos)
        if 'Amazon Elastic Compute Cloud - Compute' not in daily_services:
            daily_services.append('Amazon Elastic Compute Cloud - Compute')
        if 'Amazon Simple Storage Service' not in daily_services:
            daily_services.append('Amazon Simple Storage Service')
        
        for service in daily_services:
            # Usar custo base realista
            base_cost = service_base_costs[service]
            
            # CORRE√á√ÉO: Varia√ß√£o mais natural (¬±40% mas limitada)
            daily_variation = random.uniform(0.6, 1.4)
            cost = base_cost * daily_variation
            
            # CORRE√á√ÉO: Limitar a 2 casas decimais
            cost = round(cost, 2)
            
            # Verificar se registro j√° existe (UPSERT)
            existing = DailyFocusCosts.query.filter_by(
                aws_account_id=account_id,
                usage_date=current_date,
                aws_service=service
            ).first()
            
            if existing:
                # Atualizar existente
                existing.cost = cost
                existing.service_category = service_categories[service]
            else:
                # Criar novo registro
                new_record = DailyFocusCosts(
                    aws_account_id=account_id,
                    usage_date=current_date,
                    aws_service=service,
                    service_category=service_categories[service],
                    cost=cost
                )
                db.session.add(new_record)
                imported_count += 1
        
        current_date += timedelta(days=1)
        
        # Commit em lotes para performance
        if imported_count % 100 == 0:
            db.session.commit()
    
    # Commit final
    db.session.commit()
    
    # Garantir que history_imported seja atualizado
    account = AWSAccount.query.get(account_id)
    if account:
        account.history_imported = True
        db.session.commit()
        logging.info(f"Campo history_imported atualizado para conta {account_id}")
    
    logging.info(f"Simula√ß√£o REALISTA conclu√≠da: {imported_count} registros importados para conta {account_id}")
    print(f"‚úÖ Dados hist√≥ricos realistas gerados: {imported_count} registros")

# ============================================================================
# M√ìDULO DE ALARMES - SISTEMA DE INTELIG√äNCIA PROATIVA
# ============================================================================

@api_bp.route('/services', methods=['GET'])
@token_required
def list_services(current_user):
    """
    Endpoint para listar todos os servi√ßos AWS distintos da organiza√ß√£o.
    Usado para popular o dropdown de sele√ß√£o de servi√ßos nos alarmes.
    """
    try:
        organization_id = current_user.organization_id
        
        # Obter IDs das contas AWS da organiza√ß√£o
        account_ids = [acc.id for acc in AWSAccount.query.filter_by(
            organization_id=organization_id
        ).all()]
        
        if not account_ids:
            return jsonify([]), 200
        
        # Query para obter servi√ßos distintos
        services = db.session.query(DailyFocusCosts.aws_service).filter(
            DailyFocusCosts.aws_account_id.in_(account_ids)
        ).distinct().order_by(DailyFocusCosts.aws_service).all()
        
        # Converter para lista de strings
        service_list = [service[0] for service in services]
        
        return jsonify(service_list), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@api_bp.route('/alarms', methods=['POST'])
@token_required
def create_alarm(current_user):
    """
    Endpoint para criar uma nova regra de alarme.
    """
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'Request body cannot be empty'}), 400
        
        # Validar campos obrigat√≥rios
        required_fields = ['name', 'scope_type', 'time_period', 'severity_levels']
        for field in required_fields:
            if field not in data:
                return jsonify({'error': f'Missing required field: {field}'}), 400
        
        # Validar scope_type
        valid_scope_types = ['ORGANIZATION', 'AWS_ACCOUNT', 'SERVICE']
        if data['scope_type'] not in valid_scope_types:
            return jsonify({'error': f'Invalid scope_type. Must be one of: {valid_scope_types}'}), 400
        
        # Validar time_period
        valid_time_periods = ['DAILY', 'MONTHLY']
        if data['time_period'] not in valid_time_periods:
            return jsonify({'error': f'Invalid time_period. Must be one of: {valid_time_periods}'}), 400
        
        # Validar severity_levels
        if not isinstance(data['severity_levels'], list) or len(data['severity_levels']) == 0:
            return jsonify({'error': 'severity_levels must be a non-empty array'}), 400
        
        if len(data['severity_levels']) > 4:
            return jsonify({'error': 'Maximum 4 severity levels allowed'}), 400
        
        # Validar estrutura dos n√≠veis de severidade
        for level in data['severity_levels']:
            if not isinstance(level, dict) or 'name' not in level or 'threshold' not in level:
                return jsonify({'error': 'Each severity level must have name and threshold'}), 400
            try:
                float(level['threshold'])
            except (ValueError, TypeError):
                return jsonify({'error': 'Threshold must be a valid number'}), 400
        
        # Validar scope_value se necess√°rio
        scope_value = data.get('scope_value')
        if data['scope_type'] in ['AWS_ACCOUNT', 'SERVICE'] and not scope_value:
            return jsonify({'error': f'scope_value is required for scope_type {data["scope_type"]}'}), 400
        
        # Criar novo alarme
        new_alarm = Alarm(
            organization_id=current_user.organization_id,
            name=data['name'],
            scope_type=data['scope_type'],
            scope_value=scope_value,
            time_period=data['time_period'],
            severity_levels=data['severity_levels'],
            is_enabled=data.get('is_enabled', True),
            notification_email=data.get('notification_email')
        )
        
        db.session.add(new_alarm)
        db.session.commit()
        
        return jsonify({
            'message': 'Alarm created successfully',
            'alarm_id': new_alarm.id
        }), 201
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@api_bp.route('/alarms', methods=['GET'])
@token_required
def list_alarms(current_user):
    """
    Endpoint para listar todas as regras de alarme da organiza√ß√£o.
    """
    try:
        organization_id = current_user.organization_id
        
        alarms = Alarm.query.filter_by(organization_id=organization_id).order_by(
            Alarm.created_at.desc()
        ).all()
        
        alarms_list = []
        for alarm in alarms:
            alarms_list.append({
                'id': alarm.id,
                'name': alarm.name,
                'scope_type': alarm.scope_type,
                'scope_value': alarm.scope_value,
                'time_period': alarm.time_period,
                'severity_levels': alarm.severity_levels,
                'is_enabled': alarm.is_enabled,
                'notification_email': alarm.notification_email,
                'created_at': alarm.created_at.isoformat()
            })
        
        return jsonify(alarms_list), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@api_bp.route('/alarms/<int:alarm_id>', methods=['PUT'])
@token_required
def update_alarm(current_user, alarm_id):
    """
    Endpoint para atualizar uma regra de alarme.
    """
    try:
        # Buscar alarme e verificar se pertence √† organiza√ß√£o
        alarm = Alarm.query.filter_by(
            id=alarm_id, 
            organization_id=current_user.organization_id
        ).first_or_404()
        
        data = request.get_json()
        if not data:
            return jsonify({'error': 'Request body cannot be empty'}), 400
        
        # Atualizar campos se fornecidos
        if 'name' in data:
            alarm.name = data['name']
        
        if 'scope_type' in data:
            valid_scope_types = ['ORGANIZATION', 'AWS_ACCOUNT', 'SERVICE']
            if data['scope_type'] not in valid_scope_types:
                return jsonify({'error': f'Invalid scope_type. Must be one of: {valid_scope_types}'}), 400
            alarm.scope_type = data['scope_type']
        
        if 'scope_value' in data:
            alarm.scope_value = data['scope_value']
        
        if 'time_period' in data:
            valid_time_periods = ['DAILY', 'MONTHLY']
            if data['time_period'] not in valid_time_periods:
                return jsonify({'error': f'Invalid time_period. Must be one of: {valid_time_periods}'}), 400
            alarm.time_period = data['time_period']
        
        if 'severity_levels' in data:
            if not isinstance(data['severity_levels'], list) or len(data['severity_levels']) == 0:
                return jsonify({'error': 'severity_levels must be a non-empty array'}), 400
            
            if len(data['severity_levels']) > 4:
                return jsonify({'error': 'Maximum 4 severity levels allowed'}), 400
            
            # Validar estrutura dos n√≠veis
            for level in data['severity_levels']:
                if not isinstance(level, dict) or 'name' not in level or 'threshold' not in level:
                    return jsonify({'error': 'Each severity level must have name and threshold'}), 400
                try:
                    float(level['threshold'])
                except (ValueError, TypeError):
                    return jsonify({'error': 'Threshold must be a valid number'}), 400
            
            alarm.severity_levels = data['severity_levels']
        
        if 'is_enabled' in data:
            alarm.is_enabled = bool(data['is_enabled'])
        
        if 'notification_email' in data:
            alarm.notification_email = data['notification_email']
        
        db.session.commit()
        
        return jsonify({'message': 'Alarm updated successfully'}), 200
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@api_bp.route('/alarms/<int:alarm_id>', methods=['DELETE'])
@token_required
def delete_alarm(current_user, alarm_id):
    """
    Endpoint para deletar uma regra de alarme.
    """
    try:
        # Buscar alarme e verificar se pertence √† organiza√ß√£o
        alarm = Alarm.query.filter_by(
            id=alarm_id, 
            organization_id=current_user.organization_id
        ).first_or_404()
        
        # Deletar eventos de alarme associados primeiro
        AlarmEvent.query.filter_by(alarm_id=alarm.id).delete()
        
        # Deletar o alarme
        db.session.delete(alarm)
        db.session.commit()
        
        return jsonify({'message': 'Alarm deleted successfully'}), 200
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@api_bp.route('/alarm-events', methods=['GET'])
@token_required
def list_alarm_events(current_user):
    """
    Endpoint para listar todos os eventos de alarme da organiza√ß√£o.
    Suporta pagina√ß√£o e filtros.
    """
    try:
        organization_id = current_user.organization_id
        
        # Par√¢metros de pagina√ß√£o
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        per_page = min(per_page, 100)  # Limitar a 100 itens por p√°gina
        
        # Par√¢metros de filtro
        status_filter = request.args.get('status')
        severity_filter = request.args.get('severity')
        
        # Query base - juntar com tabela de alarmes para filtrar por organiza√ß√£o
        query = db.session.query(AlarmEvent).join(Alarm).filter(
            Alarm.organization_id == organization_id
        )
        
        # Aplicar filtros
        if status_filter:
            query = query.filter(AlarmEvent.status == status_filter)
        
        if severity_filter:
            query = query.filter(AlarmEvent.breached_severity == severity_filter)
        
        # Ordenar por data mais recente
        query = query.order_by(AlarmEvent.trigger_date.desc(), AlarmEvent.created_at.desc())
        
        # Aplicar pagina√ß√£o
        paginated_events = query.paginate(
            page=page, 
            per_page=per_page, 
            error_out=False
        )
        
        events_list = []
        for event in paginated_events.items:
            events_list.append({
                'id': event.id,
                'alarm_id': event.alarm_id,
                'alarm_name': event.alarm.name,
                'trigger_date': event.trigger_date.isoformat(),
                'cost_value': float(event.cost_value),
                'threshold_value': float(event.threshold_value),
                'breached_severity': event.breached_severity,
                'status': event.status,
                'created_at': event.created_at.isoformat(),
                'scope_type': event.alarm.scope_type,
                'scope_value': event.alarm.scope_value,
                'time_period': event.alarm.time_period
            })
        
        return jsonify({
            'events': events_list,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': paginated_events.total,
                'pages': paginated_events.pages,
                'has_next': paginated_events.has_next,
                'has_prev': paginated_events.has_prev
            }
        }), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# ============================================================================
# M√ìDULO DE ALARMES - FASE 2: WORKFLOW E NOTIFICA√á√ïES
# ============================================================================

@api_bp.route('/alarm-events/<int:event_id>/status', methods=['PUT'])
@token_required
def update_alarm_event_status(current_user, event_id):
    """
    Endpoint para atualizar o status de um evento de alarme.
    """
    try:
        # Buscar evento e verificar se pertence √† organiza√ß√£o do usu√°rio
        event = db.session.query(AlarmEvent).join(Alarm).filter(
            AlarmEvent.id == event_id,
            Alarm.organization_id == current_user.organization_id
        ).first()
        
        if not event:
            return jsonify({'error': 'Evento de alarme n√£o encontrado'}), 404
        
        data = request.get_json()
        if not data or 'new_status' not in data:
            return jsonify({'error': 'new_status √© obrigat√≥rio'}), 400
        
        new_status = data['new_status']
        comment = data.get('comment', '')
        
        # Validar transi√ß√µes permitidas
        valid_transitions = {
            'NEW': ['ANALYZING'],
            'ANALYZING': ['RESOLVED']
        }
        
        if new_status not in valid_transitions.get(event.status, []):
            return jsonify({
                'error': f'Transi√ß√£o de {event.status} para {new_status} n√£o √© permitida'
            }), 400
        
        # Validar coment√°rio obrigat√≥rio para resolu√ß√£o
        if new_status == 'RESOLVED' and not comment.strip():
            return jsonify({'error': 'Coment√°rio √© obrigat√≥rio ao marcar como resolvido'}), 400
        
        # Registrar a√ß√£o no hist√≥rico
        action = AlarmEventAction(
            alarm_event_id=event.id,
            user_id=current_user.id,
            previous_status=event.status,
            new_status=new_status,
            comment=comment
        )
        
        # Atualizar status do evento
        event.status = new_status
        
        db.session.add(action)
        db.session.commit()
        
        return jsonify({
            'message': 'Status atualizado com sucesso',
            'new_status': new_status
        }), 200
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@api_bp.route('/alarm-events/<int:event_id>/history', methods=['GET'])
@token_required
def get_alarm_event_history(current_user, event_id):
    """
    Endpoint para obter o hist√≥rico de a√ß√µes de um evento de alarme.
    """
    try:
        # Verificar se o evento pertence √† organiza√ß√£o do usu√°rio
        event = db.session.query(AlarmEvent).join(Alarm).filter(
            AlarmEvent.id == event_id,
            Alarm.organization_id == current_user.organization_id
        ).first()
        
        if not event:
            return jsonify({'error': 'Evento de alarme n√£o encontrado'}), 404
        
        # Buscar hist√≥rico de a√ß√µes
        actions = db.session.query(AlarmEventAction).join(User).filter(
            AlarmEventAction.alarm_event_id == event_id
        ).order_by(AlarmEventAction.action_timestamp.desc()).all()
        
        history = []
        for action in actions:
            history.append({
                'id': action.id,
                'user_name': action.user.email,  # Ou nome se dispon√≠vel
                'previous_status': action.previous_status,
                'new_status': action.new_status,
                'comment': action.comment,
                'action_timestamp': action.action_timestamp.isoformat()
            })
        
        return jsonify({
            'event_id': event_id,
            'history': history
        }), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500
